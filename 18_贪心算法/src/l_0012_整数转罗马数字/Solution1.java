package l_0012_整数转罗马数字;

/*

贪心算法（贪心算法的有效性未证明）

说明：

这道题能想到用贪心算法，是来源于生活中的经验，使用贪心算法有一定取巧的因素：

	这个问题直觉是贪心去做大概不会有问题；
	想举出反例推翻贪心算法，但是举不出来；
	真的用贪心算法去验证，可以通过测评。
	
如果证明不出来贪心算法的有效性，我个人觉得在绝大多数情况下是没有关系的。
有贪心选择的直觉，举不出反例，能编码实现还能过测评，就很棒了。

相同背景的问题是「找零钱问题」，这在《算法导论》（第 3 版）是有介绍的，但是已经不在我能解释的范围内了。
可以肯定的一个结论是：这道题使用贪心算法之所有有效，完全是跟给出的数据有关，换一些数值就不一定可以使用，请大家留意。

图1.png （说明：翻译版第 255 页）

生活中的经验：
	在以前还使用现金购物的时候，如果我们不想让对方找钱，付款的时候我们会尽量选择面值大的纸币给对方，
	这样才会使得我们给对方的纸币张数最少，对方点钱的时候也最方便。

本题“整数转罗马数字”也有类似的思想：
在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 11 加起来，我们总是希望写出来的“罗马数字”的个数越少越好，
以方便表示，并且这种表示方式还应该是唯一的。

思路分析：

本题中，首先给出“罗马数字”与“阿拉伯数字”的对应关系如下：

图2.png

题目还给了一些特例，我们需要推导出“罗马数字”与“阿拉伯数字”其它的对应关系。为此，从头开始举例子，以发现规律：

图3.png

说明：其实在题目中已经强调了一些特例，出现 44、99、4040、9090、400400、900900 
（40004000、90009000 不讨论了，题目测试用例中有说，不会超过 39993999）的情况比较特殊一些，
做的是减法，把它们也加入到“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。

图4.png

于是，“将整数转换为罗马数字”的过程，就是用上面这张表中右边的数字作为“加法因子”去分解一个整数，
目的是“分解的整数个数”尽可能少，因此，对于这道问题，类似于用最少的纸币凑成一个整数，贪心算法的规则如下：

每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。


作者：liweiwei1419
链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */

class Solution {

	public String intToRoman(int num) {
		// 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
		// 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
		int[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String[] romans = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };

		StringBuilder stringBuilder = new StringBuilder();
		int index = 0;
		//每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。
		while (index < 13) {
			// 特别注意：这里是等号
			while (num >= nums[index]) {
				// 注意：这里是等于号，表示尽量使用大的"面值"
				stringBuilder.append(romans[index]);
				num -= nums[index];
			}
			index++;
		}
		return stringBuilder.toString();
	}
}


public class Solution1 {

}
