第 7 章 排序算法【见/排序算法/图2.png】
----------------------------------------------------
排序算法的稳定性（Stability）：
	1.如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法。
	2.对自定义对象进行排序时，稳定性会影响最终的排序效果。
	3.冒泡排序属于稳定的排序算法。稍有不慎，稳定的排序算法也能被写成不稳定
	     的排序算法，比如下面的冒泡排序代码是不稳定的
		    public class BubbleSort1<T extends Comparable<T>> extends Sort<T> {
				@Override
				protected void sort() {
					for (int end = array.length - 1; end > 0; end--) {
						for (int begin = 1; begin <= end; begin++) {
							// if (array[begin] < array[begin - 1]) {
							if (cmp(begin, begin - 1) <= 0) {
								swap(begin, begin - 1);
							}
						}
					}
				}
			}
----------------------------------------------------
原地算法（In-place Algorithm）：
	 何为原地算法？
	 	1.不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入
	 	2.空间复杂度为 𝑂(1) 的都可以认为是原地算法
	 	3.非原地算法，称为 Not-in-place 或者 Out-of-place
	 	4.冒泡排序属于 In-place
----------------------------------------------------
----------------------------------------------------
----------------------------------------------------
----------------------------------------------------
排序算法的一般性结论：【见/排序算法/图2.png】
在排序算法中，我们可能会遇到In-place和Out-place
	in-place 占用常数内存，不占用额外内存
	out-place 占用额外内存

稳定的排序算法：
	冒泡排序，插入排序，归并排序，计数排序，基数排序，桶排序
-------------------------------------------------------
	1) 内部排序:
		指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。
	2) 外部排序法：
		数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。
	3) 常见的排序算法分类(见右图): ①②③④⑤⑥⑧⑦⑨⑩
		1.内部排序：
			1.1 插入排序：
				1.1.1 直接插入排序                                 ①(1)
				1.1.2 希尔排序                                        ②(2)
			1.2 选择排序：
				1.2.1 简单选择排序                                 ③(3)
				1.2.3 堆排序                                          ④(4)
			1.3 交换排序：
				1.3.1 冒泡排序                                       ⑤(5)
				1.3.2 快速排序                                       ⑥(6)
			1.4 归并排序                                                    ⑦(7)
			1.5 基数排序                                                    ⑩(8)
			
------------------------------------------------------
7.3.5平均时间复杂度和最坏时间复杂度
	1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下， 该算法的运行时间。
	2) 最坏情况下的时间复杂度称最坏时间复杂度。 一般讨论的时间复杂度均是最坏情况下的时间复杂度。 
	       这样做的原因是： 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限， 这就保证了算
	       法的运行时间不会比最坏情况更长。
	3) 平均时间复杂度和最坏时间复杂度是否一致， 和算法有关(如图:)
	【见图 /排序算法/图1.png】
常数阶O(1)
	无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
------------------------------------------------------
7.4 算法的空间复杂度简介
	7.4.1基本介绍
		1) 类似于时间复杂度的讨论， 一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间， 
		       它也是问题规模 n 的函数。
		2) 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需
		       要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的
		       存储单元， 例如快速排序和归并排序算法, 基数排序就属于这种情况
		3) 在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品
		   (redis, memcache)和算法(基数排序)本质就是用空间换时间.
------------------------------------------------------
