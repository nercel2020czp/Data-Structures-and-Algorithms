/**
 * 
 */
/**
 * @author 15753
 *
 */
package l_0000_双指针算法说明;
/*
https://mp.weixin.qq.com/s/yLc7-CZdti8gEMGWhd0JTg
我认为双指针技巧还可以分为两类，一类是「快慢指针」，一类是「左右指针」。
前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；「快慢指针」
后者主要解决数组（或者字符串）中的问题，比如二分查找。「左右指针」


一、快慢指针的常见算法

快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，
慢指针 slow 在后，巧妙解决一些链表中的问题。
--------------------------------
1、判定链表中是否含有环

这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。

单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。

如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，
这还好说，可以判断该链表不含环。

		boolean hasCycle(ListNode head) {
		    while (head != null)
		        head = head.next;
		    return false;
		}
		
但是如果链表中含有环，那么这个指针就会陷入死循环，
因为环形数组中没有 null 指针作为尾部节点。

经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。
如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；
如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。
	public boolean hasCycle(ListNode head) {
		ListNode fast,slow;
		fast = slow = head;
		while(fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
			if(fast == slow) return true;
		}
		return false;
	}
	
---------------------------------

2、已知链表中含有环，返回这个环的起始位置

图1.png

这个问题其实不困难，有点类似脑筋急转弯，先直接看代码：
	public ListNode detectCycle1(ListNode pHead) {
		ListNode fast, slow;
		fast = slow = pHead;
		while(fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
			if(fast == slow) break;
		}
		slow = pHead;
		while(slow != fast) {
			slow = slow.next;
			fast = fast.next;
		}
		return slow;
	}

1. 这题我们可以采用双指针解法，一快一慢指针。快指针每次跑两个element，慢指针每次跑一个。
       如果存在一个圈，总有一天，快指针是能追上慢指针的。
       
2. 如图1.png所示，我们先找到快慢指针相遇的点，p。我们再假设，环的入口在点q，从头节点到点q距离
       为A，q p两点间距离为B，p q两点间距离为C。       
       
3. 因为快指针是慢指针的两倍速，且他们在p点相遇，则我们可以得到等式 2(A+B) = A+B+C+B.

4. 由3的等式，我们可得，C = A。

5. 这时，因为我们的slow指针已经在p，我们可以新建一个另外的指针，slow2，让他从头节点开始走，
       每次只走下一个，原slow指针继续保持原来的走法，和slow2同样，每次只走下一个。      
       
6. 我们期待着slow2和原slow指针的相遇，因为我们知道A=C，所以当他们相遇的点，一定是q了。

7. 我们返回slow2或者slow任意一个节点即可，因为此刻他们指向的是同一个节点，即环的起始点，q。 
---------------------------------
3、寻找链表的中点
类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。
---------------------------------
4、寻找链表的倒数第 k 个元素

///////////////////////////////////////////////////////////
二、左右指针的常用算法
左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。
1、二分查找
前文 二分查找算法详解 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：

*/

