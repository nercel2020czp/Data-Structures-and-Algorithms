package l_0032_最长有效括号_longest_valid_parentheses_Revise;
/*
	算法

首先定义动态规划的数组代表什么

dp[i] 代表以下标 i 结尾的合法序列的最长长度，例如   图1.png

下标 1 结尾的最长合法字符串长度是 2，下标 3 结尾的最长字符串是 str[0,3]，长度是 4 。

我们来分析下 dp 的规律。

首先我们初始化所有的 dp 都等于零。

以左括号结尾的字符串一定是非法序列，所以 dp 是零，不用更改。

以右括号结尾的字符串分两种情况。

	1)右括号前边是 ( ，类似于 ……()。
		dp[i] = dp[i-2] + 2 （前一个合法序列的长度，加上当前新增的长度 2）
		类似于上图中 index = 3 的时候的情况。
		dp[3] = dp[3-2] + 2 = dp[1] + 2 = 2 + 2 = 4

	2)右括号前边是 )，类似于 ……))。
		此时我们需要判断 i - dp[i-1] - 1 （前一个合法序列的前边一个位置） 是不是左括号。
		
		例如图1的 index=7 的时候，此时 index-1 也是右括号，我们需要知道 
		i-dp[i-1]-1=7-dp[6]-1= 4 位置的括号的情况。
		
		而刚好 index = 4 的位置是左括号，此时 dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2 
		（当前位置的前一个合法序列的长度，加上匹配的左括号前边的合法序列的长度，加上新增的长度 2），也就
		是 dp[7] = dp[7-1] + dp[7 - dp[7-1] - 2] + 2 = dp[6] + dp[7-2-2] + 2 = 2 + 4 + 2 = 8。
		
		如果 index = 4 不是左括号，那么此时位置 7 的右括号没有匹配的左括号，所以 dp[7] = 0 ，不需要更新。

	上边的分析可以结合图看一下，可以更好的理解，下边看下代码。
	
	

*/
public class Solution1 {
	public int longestValidParentheses(String s) {
	    int maxans = 0;
	    int dp[] = new int[s.length()];
	    for (int i = 1; i < s.length(); i++) {
	        if (s.charAt(i) == ')') {
	            //右括号前边是左括号
	            if (s.charAt(i - 1) == '(') {
	                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
	            //右括号前边是右括号，并且除去前边的合法序列的前边是左括号
	            } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
	                dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
	            }
	            maxans = Math.max(maxans, dp[i]);
	        }
	    }
	    return maxans;
	}
	
/*	
	时间复杂度：遍历了一次，O（n）。
	空间复杂度：O（n）。
*/	
}
