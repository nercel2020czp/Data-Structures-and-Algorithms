https://blog.csdn.net/lisonglisonglisong/article/details/41548557
# 动态规划


动态规划（Dynamic Programming）是一种<font color=B000> **设计的技巧** </font>，是解决 <font color=0BBB>**多阶段决策过程最优化问题** </font>的通用方法。


基本思想：将待求解问题分解成 **若干个子问题**，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往 **不是互相独立** 的。若用分治法来解这类问题，则分解得到的 <font color=B888>***子问题数目太多*** </font>，有些子问题<font color=0BBB> **被重复计算了很多次** </font>。如果我们能够<font color=B000> **保存已解决的子问题的答案** </font>，而在需要时再找出已求得的答案，这样就可以<font color=0BBB> **避免大量的重复计算，节省时间** </font>。通常可以<font color=B888> **用一个表来记录所有已解的子问题的答案** </font>。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路。


采用动态规划求解的问题需要具有 <font color=0BBB>**两个特性** </font>：


> <font color=B000> **最优子结构（Optimal Substructure）** </font>：问题的一个最优解中所包含的子问题的解也是最优的。
> 
> <font color=B000> **重叠子问题（Overlapping Subproblems）** </font>：用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。


问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。

综上所述，动态规划的关键是 —— **记忆，空间换时间**，不重复求解，<font color=B888>**从较小问题解逐步决策，构造较大问题的解** </font>。

③ 动态规划求解

简单的递归之所以和穷举法一样慢，因为在 **递归过程中进行了大量的重复调用** 。而动态规划就是要解决这个问题，通过用一个表来保存子问题的结果，**避免重复的计算，以空间换时间**。前面我们已经证明，最长公共子序列问题具有动态规划所要求的两个特性，所以 LCS 问题可以用动态规划来求解。

## **总结：**

动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。**其中的关键在于解决冗余（重复计算），这是动态规划算法的根本目的**。 动态规划实质上是一种<font color=B000> **以空间换时间** </font>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

从上面的例子中，我们可以总结动态规划解决最优化问题的一般步骤：

> 分析最优解的性质，并刻划其结构特征。
> 
> 递归地定义最优值。
> 
> 以自底向上的方式或自顶向下的记忆化方法计算出最优值。
> 
> 根据计算最优值时得到的信息，构造一个最优解。

步骤(1)—(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。

但是我们还能这样进一步考虑，将递归转化为递推，将自顶向下的思路转换为自底向上，这也是记忆化搜索和DP之间的区别所在。
【见/动态规划/src/t0343_整数拆分_integer_break/Solution3.java】