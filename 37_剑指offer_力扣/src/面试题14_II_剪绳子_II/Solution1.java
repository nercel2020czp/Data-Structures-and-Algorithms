package 面试题14_II_剪绳子_II;
/*
首先，任何一个数字 n，都可以被分为有限个小数字之和 n = n_1 + n_2 + ... + n_M
根据常理： 一般这 M 个数字的乘积要大于原数字 n。
其次，所有数字n 都可以通过对一个因子 x 求整数部分 a（a = n / x） 和余数部分 b （ b = n % x）；
即得出数字 n 由 a 个 x 和 1 个 b 相加而成。
问题转化： 是否有优先级最高的因子 x 存在？若有，我们就可以把问题转化为求 x^a * b这个表达式的最大值。
例如：2=1+1，1 * 1 < 2，因此 2 比 1+1 更优；
例如：3=1+2，1 * 2 < 3，因此 3 比 1 和 2 更优；
例如：4=2+2，2 * 2 = 4，因此可以认为 4 与 2 等价，因此见到 4 就拆分；
例如：5=2+3；因为每个 5 都可以拆分为 2+3，而 2 * 3 = 6 > 5，因此见到 5 就拆分。
例如：6=3+3=2+2+2；因为 3 * 3 > 2 * 2 * 2 > 6。因此见到 6 就拆分，并且 3 是比 2 更优的因子。
易推出： 大数字都可以被拆分为多个小因子，以获取更大的乘积，只有 2 和 3 不需要拆分。
见图2.png

观察以上枚举，我们可以列出以下贪心法则：
第一优先级： 3；把数字 n 拆成尽可能多的 3 之和；
	特殊情况： 拆完后，如果余数是 1；则应把最后的 3+1 替换为2+2，因为后者乘积更大；
第二优先级： 2；留下的余数如果是 2，则保留，不再拆为 1+1。	
---------------------------------------------------------------
最高优先级： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。
次高优先级： 2 。若最后一段绳子长度为 2，则保留，不再拆为 1+1 。
最低优先级： 1； 若最后一段绳子长度为 1；则应把最后的 3+1 替换为 2+2，因为 2×2>3×1。

算法流程：
	1.当 n≤3 时，按照贪心规则应直接保留原数字，但由于题目要求必须剪成 m>1 段，因此必须剪出一段长度为 1 的绳子，即返回 n−1 。
	2.当 n>3 时，求 n 除以 33 的 整数部分 a 和 余数部分 b （n=3a+b ），并分为以下三种情况（设求余操作符号为 "⊙" ）：
		① 当 b=0 时，直接返回 3^a ⊙ 1000000007；//①②③④⑤⑥⑦⑧⑨⑩
		② 当 b=1 时，要将一个 1+3 转换为 2+2，因此返回 (3^{a-1} * 4)⊙1000000007；
		③ 当 b=2 时，返回 (3^a * 2) ⊙ 1000000007。
		
大数求余解法：
	大数越界： 当 a 增大时，最后返回的 3^a大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。
	本题的大数求余问题： 在仅使用 int32 类型存储的前提下，正确计算 x^a 对 p 求余（即 x^a ⊙ p ）的值。
	解决方案： 循环求余 、 二分求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：
		(xy)⊙p=[(x⊙p)(y⊙p)]⊙p
		
1. 循环求余法：	【图2.png】
	# 求 (x^a) % p —— 循环求余法
	def remainder(x, a, p):
	    rem = 1
	    for _ in range(a):
	        rem = (rem * x) % p
	    return rem

2. 二分求余法：【图3.png】
	# 求 (x^a) % p —— 二分求余法
	def remainder(self, x, a, p):
	    rem = 1
	    while a > 0:
	        if a % 2: rem = (rem * x) % p
	        x = x ** 2 % p
	        a //= 2
	    return rem


帮助理解：【见图4.png】

复杂度分析：【见图5.png】

代码：
	Python 代码（第三栏）： 由于语言特性，理论上 Python 中的变量取值范围由系统内存大小决定（无限大），
	因此在 Python 中其实不用考虑大数越界问题。
	Java 代码： 根据二分法计算原理，至少要保证变量x 和 rem 可以正确存储 1000000007^2 ，
	而 2^{64} > 1000000007^2 > 2^{32} ，因此我们选取 long 类型。

作者：jyd
链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
		③④⑤⑥⑦⑧⑨⑩

*/
public class Solution1 {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        int b = n % 3, p = 1000000007;
        long rem = 1, x = 3;
        for(int a = n / 3 - 1; a > 0; a /= 2) {
            if(a % 2 == 1) 
            	rem = (rem * x) % p;
            x = (x * x) % p;
        }
        if(b == 0) return (int)(rem * 3 % p);
        if(b == 1) return (int)(rem * 4 % p);
        return (int)(rem * 6 % p);
    }
/*    执行用时 :
    	0 ms
    	, 在所有 Java 提交中击败了
    	100.00%
    	的用户
    	内存消耗 :
    	36.4 MB
    	, 在所有 Java 提交中击败了
    	100.00%
    	的用户*/
}
