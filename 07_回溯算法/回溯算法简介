方法：回溯
回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，
回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。
-----------------------------------
你好，我一直弄不懂什么场景用BFS，什么时候又该使用DFS，有什么技巧吗或者推荐我一些
典型题也行，跪求，已经被折磨好久了[哭泣]

其实我也没有认真总结过耶。现在我简单总结一下，水平有限，仅供您参考哦。
BFS 和 DFS 本质上都是遍历，所以只要是需要遍历的算法，理论上都可以使用 DFS 或者 BFS。它们各自的特点和适用场景如下：

1、BFS 由于是水波纹式的扩散，它可以用于一些求解最短路径以及最优化问题，或者是可以用贪心算法解决的问题上，
	例如第 126 题、第 127 题 单词接龙，第 207 题、第 210 题：课程表，第 279 题：完全平方数，第 994 题：腐烂的橘子。
2、DFS 的基本思想也很简单，就是一条道走到底，只要前面有路就一直向前走，不撞南墙不回头。很多时候走迷宫就是这么走的。

DFS 如果用于搜索状态空间，就是大名鼎鼎的回溯搜索算法，它厉害的地方在于，可以使用一个状态变量去搜索所有的状态空间，
这一点是节约空间的。我们可以想象用一根绳子，在遍历的时候变长变短，遍历的同时保存下来我们需要的那个状态。
BFS 就做不到，BFS 为了遍历就需要保存全部的状态，对于空间来说是个巨大的消耗。

回溯算法的例题我有总结：在第 46 题的 题解 的最后。
https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
希望我的回答能对您有帮助，如果有我没有说清楚的地方，欢迎继续交流。
----------------------------------------------------
题目	提示
47. 全排列 II	思考一下，为什么造成了重复，如何在搜索之前就判断这一支会产生重复，从而“剪枝”。
17 .电话号码的字母组合	
22. 括号生成	这是字符串问题，没有显式回溯的过程。这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。
39. 组合总和	使用题目给的示例，画图分析。
40. 组合总和 II	
51. N皇后	其实就是全排列问题，注意设计清楚状态变量。
60. 第k个排列	利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点。
77. 组合	组合问题按顺序找，就不会重复。并且举一个中等规模的例子，找到如何剪枝，这道题思想不难，难在编码。
78. 子集	为数不多的，解不在叶子结点上的回溯搜索问题。解法比较多，注意对比。
90. 子集 II	剪枝技巧同 47 题、39 题、40 题。
93. 复原IP地址	
784. 字母大小写全排列	

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

-----------------------------------------------
至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，
应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，
但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，
因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，
回溯算法就是纯暴力穷举，复杂度一般都很高。

明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。
