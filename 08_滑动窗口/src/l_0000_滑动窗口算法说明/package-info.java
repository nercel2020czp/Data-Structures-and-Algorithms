/**
 * 
 */
/**
 * @author 15753
 *
 */
package l_0000_滑动窗口算法说明;
/*

1、链表子串数组题，用双指针别犹豫。

2、双指针家三兄弟，各个都是万人迷。

3、快慢指针最神奇，链表操作无压力。

4、归并排序找中点，链表成环搞判定。

5、左右指针最常见，左右两端相向行。

6、反转数组要靠它，二分搜索是弟弟，

7、滑动窗口老猛男，子串问题全靠它。

8、左右指针滑窗口，一前一后齐头进。

https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA
说起滑动窗口算法，很多读者都会头疼。
这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。
LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。
该算法的大致逻辑如下：

		int left = 0, right = 0;
		while (right < s.size()) {
		    // 增大窗口
		    window.add(s[right]);
		    right++;
		
		    while (window needs shrink) {
		        // 缩小窗口
		        window.remove(s[left]);
		        left++;
		    }
		}
		
这个算法技巧的时间复杂度是 O(N)，比一般的字符串暴力算法要高效得多。

其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，
如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，
找 bug 还不知道怎么找，真的挺让人心烦的。

所以今天我就写一套滑动窗口算法的代码框架，我连在哪里做输出 debug 都给你写好了，
以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出边界问题：

	// 滑动窗口算法框架 
	void slidingWindow(string s, string t) {
	    unordered_map<char, int> need, window;
	    for (char c : t) need[c]++;
	
	    int left = 0, right = 0;
	    int valid = 0; 
	    while (right < s.size()) {
	        // c 是将移入窗口的字符
	        char c = s[right];
	        // 右移窗口
	        right++;
	        // 进行窗口内数据的一系列更新
	        ...
	
	        // debug 输出的位置 
	        printf("window: [%d, %d)\n", left, right);
	
	        // 判断左侧窗口是否要收缩
	        while (window needs shrink) {
	            // d 是将移出窗口的字符
	            char d = s[left];
	            // 左移窗口
	            left++;
	            // 进行窗口内数据的一系列更新
	            ...
	        }
	    }
	}
其中两处...表示的更新窗口数据的地方，到时候你直接往里面填就行了。

而且，这两个...处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。

说句题外话，其实有很多人喜欢执着于表象，不喜欢探求问题的本质。
比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；
还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。

我也是服了，算法看的是时间复杂度，你能确保自己的时间复杂度最优就行了。
至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，
根本不值得你从编译层面优化，不要舍本逐末……

labuladong 公众号的重点在于算法思想，你把框架思维了然于心套出解法，
然后随你再魔改代码好吧，你高兴就好。

言归正传，下面就直接上四道 LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。

本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，
以免有的读者因为语言的细节问题阻碍对算法思想的理解：

unordered_map就是哈希表（字典），它的一个方法count(key)相当于 Java 
的containsKey(key)可以判断键 key 是否存在。

可以使用方括号访问键对应的值map[key]。需要注意的是，如果该key不存在，C++ 会自动创建这个 key，并把map[key]赋值为 0。

所以代码中多次出现的map[key]++相当于 Java 的map.put(key, map.getOrDefault(key, 0) + 1)。
*/