/**
 * 
 */
/**
 * @author 15753
 *
 */
package l_0076_最小覆盖子串_minimum_window_substring;
/*

https://leetcode-cn.com/problems/minimum-window-substring/
76. 最小覆盖子串【困难】
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
说明：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。

class Solution {
    public String minWindow(String s, String t) {

    }
}
----------------------思路分析-------------------------
就是说要在S(source) 中找到包含T(target) 中全部字母的一个子串，
且这个子串一定是所有可能子串中最短的。

如果我们使用暴力解法，代码大概是这样的：
		for (int i = 0; i < s.size(); i++)
		    for (int j = i + 1; j < s.size(); j++)
		        if s[i:j] 包含 t 的所有字母:
		            更新答案
            思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。

滑动窗口算法的思路是这样：
	1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，
	      把索引左闭右开区间[left, right)称为一个「窗口」。
         2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串
              符合要求（包含了T中的所有字符）。
	3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，
	      直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。
	      同时，每次增加left，我们都要更新一轮结果。
	4、重复第 2 和第 3 步，直到right到达字符串S的尽头。
	
这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，
最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，
这就是「滑动窗口」这个名字的来历。

下面画图理解一下，needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。

图。。。。。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。
现在我们来看看这个滑动窗口代码框架怎么用：

首先，初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符：
	unordered_map<char, int> need, window;
	for (char c : t) need[c]++;

然后，使用left和right变量初始化窗口的两端，不要忘了，
区间[left, right)是左闭右开的，所以初始情况下窗口没有包含任何元素：
		int left = 0, right = 0;
		int valid = 0; 
		while (right < s.size()) {
		    // 开始滑动
		}
		
其中valid变量表示窗口中满足need条件的字符个数，
如果valid和need.size的大小相同，则说明窗口已满足条件，
已经完全覆盖了串T。

现在开始套模板，只需要思考以下四个问题：
	1、当移动right扩大窗口，即加入字符时，应该更新哪些数据？
	2、什么条件下，窗口应该暂停扩大，开始移动left缩小窗口？
	3、当移动left缩小窗口，即移出字符时，应该更新哪些数据？
	4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？
	
	如果一个字符进入窗口，应该增加window计数器；
	如果一个字符将移出窗口的时候，应该减少window计数器；
	当valid满足need时应该收缩窗口；
	应该在收缩窗口的时候更新最终结果。
	
下面是完整代码：

*/