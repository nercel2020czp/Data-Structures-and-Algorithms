package t046_孩子们的游戏_圆圈中最后剩下的数;
/*解法3：数学方法（迭代与递归）
【思路】
	1.n个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字记为f(n,m)
	2.n个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n
	3.那么剩下的n-1个数字就变成了：0,1,...,k-1,k+1,...,n-1，我们把下一轮第一个数字排在最前面，
	     并且将这个长度为n-1的数组映射到0~n-2。

		原始数组	映射数字
		k+1		0
		k+2		1
		...		...
		n-1		n-k-2
		0		n-k-1
		...		...
		k-1		n-2

把映射数字记为x，原始数字记为y，那么映射数字变回原始数字的公式为:
			y=(x+k+1) mod n

在映射数字中，n-1个数字，不断删除第m个数字，由定义可以知道，最后剩下的数字为f(n-1,m)。
我们把它变回原始数字，由上一个公式可以得到最后剩下的原始数字是（f(n-1,m)+k+1)%n，而这
个数字也就是一开始我们标记的f(n,m)，所以可以推得递归公式为
		f(n,m)=（f(n−1,m)+k+1) mod n

将k=(m-1)%n代入，化简得到：
		f(n,m)=（f(n−1,m)+m)modn，且f(1,m)=0
		
代码中可以采用迭代或者递归的方法实现该递归公式。时间复杂度为O(n)，空间复杂度为O(1)
注意公式中的mod就等同于%，为取模运算。值得注意的是，在数学中，下式成立：(a%n+b)%n=(a+b)%n		

作者：yuanninesuns
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/si-chong-fang-fa-xiang-xi-jie-da-by-yuanninesuns/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/
public class Solution3 {
	//迭代
	public int lastRemaining(int n, int m) {
	    int flag = 0;   
	    for (int i = 2; i <= n; i++) {
	        flag = (flag + m) % i;
	        //动态规划的思想，将f(n,m)替换成flag存储
	    }
	    return flag;
	}

	//递归
	public int lastRemaining1(int n, int m){
	    if(n < 1 || m < 1)       
	        return -1;
	    if(n == 1)
	        return 0;
	    return (lastRemaining(n-1, m) + m) % n;
	}
}
/*
约瑟夫环问题：n个人围成一圈，第一个人从1开始报数，报m的将被淘汰，下一个人接着从1开始报。
如此反复，最后剩下一个，求最后的胜利者。
递推公式：f(n,m)=[f(n-1,m)+m]%n，其中f(i,j)表示当问题规模为i，报数长度为j时最后胜利者的编号。
证明：使用数学归纳法进行证明。

当n=1时：
	f(1,m)=0，因为编号从0开始且只有一个人，胜利者编号显然为0。

当n=2时：
	序列为0,1，若m为奇数，则胜利者编号为1；若m为偶数，则胜利者编号为0，
	易有f(2,m)=m%2=(0+m)%2=[f(1,m)+m]%2，结论成立。

假设当n=i-1时结论成立:
	即对于序列0,1,2,...,i-2而言，最后的胜利者编号为f(i-1,m)。
	
当n=i时，序列为0,1,2,...,i-1。
	设第一轮的淘汰者编号为k（若m%i=0，则k=i-1，否则k=m%i-1），
	则序列可表示为0,1,2,...,k-1,k,k+1,...,i-1。第一轮淘汰k，
	余下的序列x'为k+1,...,i-1,0,1,...,k-1，问题规模变为i-1。
	
	因为由归纳假设，当n=i-1时，
		对于序列x:0,1,2,...,f(i-1,m),...,i-2，胜利者编号为f(i-1,m)。
		由于x'=(x+k+1)%i，故f(i,m)=[f(i-1,m)+k+1]%i。//关键是这一行
	当m%i=0时，k+1=i，
		[f(i-1,m)+k+1]%i = [f(i-1,m)+i]%i = f(i-1,m)%i+0 
		= f(i-1,m)%i+m%i = [f(i-1,m)+m]%i；
	当m%i!=0时，k+1=m%i，
		[f(i-1,m)+k+1]%i=[f(i-1,m)+m%i]%i=[f(i-1,m)+m]%i。
	故当n=i时，结论成立。
	综上，命题成立。

	感想：因为当n=i-1时，对于序列x:0,1,2,...,f(i-1,m),...,i-2，胜利者编号为f(i-1,m)。
	对于问题规模为i时，经过第一轮淘汰，得到序列x'。只要能够发现x与x'间的对应关系，
	由f(i-1,m)就能得到f(i,m)。*/
