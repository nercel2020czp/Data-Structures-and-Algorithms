package t050_数组中重复的数字;
/*1. 分析
思想：数组的长度为 n 且所有数字都在 0 到 n-1 的范围内，我们可以将每次遇到的数进行"归位"，
	当某个数发现自己的"位置"被相同的数占了，则出现重复。
	
扫描整个数组，当扫描到下标为 i 的数字时，首先比较该数字（m）是否等于 i：
	如果是，则接着扫描下一个数字；
	如果不是，则拿 m 与第 m 个数比较。
		如果 m 与第 m 个数相等，则说明出现重复了；
		如果 m 与第 m 个数不相等，则将 m 与第 m 个数交换，将 m "归位"
	再重复比较交换的过程，直到发现重复的数
	
	
举个栗子：
	以数组 {2,3,1,0,2,5,3} 为例
	当 i = 0 时，nums[i] = 2 != i：
		判断 nums[i] 不等于 nums[nums[i]]：
			交换 nums[i] 和 nums[nums[i]]
	
	交换后数组为：{1,3,2,0,2,5,3}
	-------------------------------------
	此时 i = 0，nums[i] = 1 != i，
		判断 nums[i] 不等于 nums[nums[i]]
			交换 nums[i] 和 nums[nums[i]]

	交换后数组为：{3,1,2,0,2,5,3}
	-------------------------------------
	此时 i = 0，nums[i] = 3 != i,
		判断 nums[i] 不等于 nums[nums[i]],
			交换 nums[i] 和 nums[nums[i]]

	交换后数组为：{0,1,2,3,2,5,3}
	-------------------------------------
	此时 i = 0，nums[i] = 0 = i，继续下一组
	-------------------------------------
	当 i = 1，nums[i] = 1 = i，继续下一组
	-------------------------------------
	当 i = 2，nums[i] = 2 = i，继续下一组
	-------------------------------------
	当 i = 3，nums[i] = 3 = i，继续下一组
	-------------------------------------
	当 i = 4，nums[i] = 2 != i
		判断 nums[i] 等于 nums[nums[i]]
			出现重复，赋值返回


 */
public class Solution3 {
/*	扫描整个数组，当扫描到下标为 i 的数字时，首先比较该数字（m）是否等于 i：
	如果是，则接着扫描下一个数字；
	如果不是，则拿 m 与第 m 个数比较。
		如果 m 与第 m 个数相等，则说明出现重复了；
		如果 m 与第 m 个数不相等，则将 m 与第 m 个数交换，将 m "归位"
	再重复比较交换的过程，直到发现重复的数*/
	public boolean duplicate(int nums[], int length, int[] duplication) {
		if (nums == null || length == 0) {
			return false;
		}
		//扫描整个数组，当扫描到下标为 i 的数字时，首先比较该数字（m）是否等于 i：
		for (int i = 0; i < length; i++) {
			while (nums[i] != i) {
				//如果不是，则拿 m 与第 m 个数比较。
				if (nums[i] == nums[nums[i]]) {
					//如果 m 与第 m 个数相等，则说明出现重复了；
					duplication[0] = nums[i];
					return true;
				}
				// swap 如果 m 与第 m 个数不相等，则将 m 与第 m 个数交换，将 m "归位"
				int tmp = nums[i];
				nums[i] = nums[tmp];
				nums[tmp] = tmp;
			}
			//如果是，则接着扫描下一个数字；
		}
		return false;
	}
}
