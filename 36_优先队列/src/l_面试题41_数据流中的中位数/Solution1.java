package l_面试题41_数据流中的中位数;

import java.util.Comparator;
import java.util.PriorityQueue;

/*


首先按照我们的尝试，中位数奇数正好前后对半，取出来即可。
偶数呢，前后难以对半，只能折中，取靠近中间的两个数之和求均值。

没错，这一题也是如此。但是如何动态的求均值呢。如何在任意时刻都能够
直接拿到我们想要的均值而不去计算下标取值呢？百思不得其解。

参考他人的想法，使用优先队列PriorityQueue，然后问题就变得很简单了。
这一题主要的思想是利用优先队列，优先队列分为大顶堆和小顶堆，默认维护的是小顶堆的优先队列。

思路：
	1.需要求的是中位数，如果我将 1 2 3 4 5 6 7 8定为最终的数据流
	2.此时的中位数是4+5求均值。为什么是4，为什么是5
	3.利用队列我们就可以看得很清楚，4是前半部分最大的值，肯定是维系在大顶堆
	4.而5是后半部分的最小值，肯定是维系在小顶堆。
	5.问题就好理解了：
		使用小顶堆存大数据，使用大顶堆存小数据。这样堆顶一取出就是中位数了。
		
解题思路：
	1.先用java集合PriorityQueue来设置一个小顶堆和大顶堆
	2.主要的思想是：
		因为要求的是中位数，那么这两个堆，大顶堆用来存较小的数，从大到小排列；
	3.小顶堆存较大的数，从小到大的顺序排序*，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。
		⭐保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，
			并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值
		⭐当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；
		⭐当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；
		⭐取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；
		   如果当前个数为奇数，显然是取小顶堆的根节点
       
        理解了上面所述的主体思想，下面举个例子辅助验证一下。
 
  @@@@@@@@@@  举个例子     @@@@@@@@@@@
    例如，传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，
    输出是"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "
    1、 5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[5],max=[无]，avg=[5.00]
    2、 2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[5],max=[2], avg=[(5+2)/2]=[3.50]
    3、 先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,5],max=[2],avg=[3.00]
    4、 4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5],max=[3,2],avg=[(4+3)/2]=[3.50]
    5、 1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,4,5],max=[2,1]，avg=[3/00]
    6、 6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5,6],max=[3,2,1],avg=[(4+3)/2]=[3.50]
    7、 7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1],avg=[4]=[4.00]
    8、 0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1,0],avg=[(4+3)/2]=[3.50]
    9、 8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，此时min=[4,5,6,7,8],max=[3,2,1,0],avg=[4.00]
*/
public class Solution1 {

	// 小顶堆
	private PriorityQueue<Integer> minHeap = new PriorityQueue<>();
	// 大顶堆
	private PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(15, new Comparator<Integer>() {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1;
		}
	});

	// 记录偶数个还是奇数个
	int count = 0;

	// 每次插入小顶堆的是当前大顶堆中最大的数
	// 每次插入大顶堆的是当前小顶堆中最小的数
	// 这样保证小顶堆中的数永远大于等于大顶堆中的数
	// 中位数就可以方便地从两者的根结点中获取了
	public void Insert(Integer num) {
		// 个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中
		if (count % 2 == 0) {// if((count & 1) == 0)
			maxHeap.offer(num);
			int max = maxHeap.poll();
			minHeap.offer(max);
		} else {
			// 个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中
			minHeap.offer(num);
			int min = minHeap.poll();
			maxHeap.offer(min);
		}
		count++;
	}

	public Double GetMedian() {
		// 当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均
		if (count % 2 == 0) {// if((count & 1) == 0)
			return new Double(minHeap.peek() + maxHeap.peek()) / 2;
		} else {
			// 当前为奇数个，则直接从小顶堆中取元素即可
			return new Double(minHeap.peek());
		}
	}

}
